# -*- coding: utf-8 -*-

import pyloco
import numpy


class NCPlot(pyloco.Task):
    """Read a NCD data and generate plot(s)

'ncplot' task reads a NCD data and generates plots.

Examples
---------
"""
    _name_ = "ncplot"
    _version_ = "0.1.0"
    _install_requires = ["matplot", "numpy"]

    def __init__(self, parent):

        self.aliases = {
            "x": "lat",
            "y": "lon",
            "z": "plev",
            "t": "time",
            "name": "long_name",
            "unit": "units",
            "dimension": "dimensions"
        }

        alias_str = ", ".join([k+"="+v for k,v in self.aliases.items()])

        self._cache = {}
        self._names = {}

        self.add_data_argument("data", required=True, help="NCD data")

        self.add_option_argument("-x", "--xdim", type=str, default=self.aliases["x"],
                help="x dimension variable name(default=%s)" % self.aliases["x"], metavar="name")
        self.add_option_argument("-y", "--ydim", type=str, default=self.aliases["y"],
                help="y dimension variable name(default=%s)" % self.aliases["y"], metavar="name")
        self.add_option_argument("-z", "--zdim", type=str, default=self.aliases["z"],
                help="z dimension variable name(default=%s)" % self.aliases["z"], metavar="name")
        self.add_option_argument("-t", "--tdim", type=str, default=self.aliases["t"],
                help="time dimension variable name(default=%s)" % self.aliases["t"], metavar="name")
        self.add_option_argument("-v", "--variable", type=str, action="append",
                help="variable name to plot", metavar="name")
        self.add_option_argument("-p", "--plot", type=str, action="append", param_parse=True,
                help="plot type(default=['contour']", metavar="plot")

        self.add_option_argument("-l", "--list", action="store_true",
                help="list variables in a netcdf file")
        self.add_option_argument("-s", "--summary", action="store_true",
                help="variable information")
        self.add_option_argument("-a", "--alias", action="append", metavar="attr=name",
                help="change dimension names or variable attribute names. Defaults are (%s)" % alias_str, param_parse=True)

        self.register_forward("data",
                help="netcdf variables in Python dictionary")

    def _desc(self, names, data, verbose=False, namepath="/"):

        dimensions = data["dimensions"]
        variables = data["variables"]
        groups = data["groups"]

        for name in names:
            if name in dimensions:
                continue

            var = variables[name]

            long_name = var.get(self.aliases["name"], "no descriptive name is found")
            units = var.get(self.aliases["unit"], "unit-unknown")
            dims = var.get(self.aliases["dimension"], "dimension-unknown")
            print("{0}:\t{1} ({2}, {3})".format(name, long_name, units, dims))

            if verbose:
                for attr, value in var.items():
                    if attr in ("data", self.aliases["name"], self.aliases["unit"], self.aliases["dimension"]):
                        continue
                    print("    - {0}: {1}".format(attr, str(value)))
                print("")

        for gname, group in groups.items():
            newpath = "%s/%s" % (namepath, gname)
            print("\n[%s]" % newpath)
            self._desc(group["variables"].keys(), group, verbose=verbose, namepath=newpath)

    def perform(self, targs):

        # dimensions, variables, attributes, groups
        indata = targs.data

        if targs.alias:
            for alias in targs.alias:
                self.aliases.update(alias.kwargs)

        if targs.list:

            print("\n[root group]")
            self._desc(indata["variables"].keys(), indata) 

            return

        if targs.summary:

            if not targs.variable or any([v=="*" for v in targs.variable]):
                svars = indata["variables"].keys()

            else:
                svar = targs.variable

            for svar in svars:
                group = None
                name = None
                for item in svar.split("/"):
                    name = item
                    if group is None:
                        group = indata
                    else:
                        import pdb; pdb.set_trace()
                        group = group["groups"][item]
            
                if name and group:
                    self._desc([name], group, verbose=True) 

            return

        self._names["X"] = targs.xdim
        self._names["Y"] = targs.ydim
        self._names["Z"] = targs.zdim
        self._names["T"] = targs.tdim

        if targs.plot:
            plots = []

            for opt in targs.plot:
                if len(opt.context) == 0:
                    plot = self.plot_contour

                elif len(opt.context) ==1:
                    plot = getattr(self, "plot_"+opt.context[0])

                elif len(opt.context) ==2:
                    import pdb; pdb.set_trace()

                else:
                    print("More than two contexts: %s" % str(opt.context))
                    continue

                opt.context = []
                plots.append((plot, str(opt)))
        else:
            plots = [(self.plot_contour, "")]

        if targs.variable:
            plotvars = targs.variable
        else:
            plotvars = indata.keys()

        for plot, params in plots:
            for varname in plotvars:
                plot(indata[varname], params)

        #self.add_forward(data=outdata)

    def plot_contour(self, data, params):

        forward = {"data": self.split_data(data, "XYD")}

        params = ", " + params if params else ""
        plot_arg = ("_{data[0]:arg}_, _{data[1]:arg}_,"
                    "_{data[2]:arg}_%s@contour" % params)

        argv = [
            "-p", plot_arg,
        ]

        pyloco.perform("matplot", argv=argv, forward=forward)


    def split_data(self, data, datatypes):

        outdata = []
        dimensions = data["dimensions"]
        import pdb; pdb.set_trace()

        for datatype in datatypes:
            if datatype == "X":
                import pdb; pdb.set_trace()
            elif datatype == "Y":
                import pdb; pdb.set_trace()
            elif datatype == "Z":
                import pdb; pdb.set_trace()
            elif datatype == "T":
                import pdb; pdb.set_trace()
            elif datatype == "D":
                import pdb; pdb.set_trace()
            else:
                raise Exception("Unknown datatype: %s" % datatype)

            outdata.append(output)

        return outdata
